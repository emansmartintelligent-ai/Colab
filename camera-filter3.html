<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Processor v3.1</title>
    <style>
        :root { --accent: #00d4ff; --bg: #0f0f12; --panel: #1e1e24; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        
        .main-layout { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 1400px; width: 100%; }
        
        /* Layout Controls */
        .viewport-section { flex: 1; min-width: 600px; }
        .canvas-container { position: relative; background: #000; border-radius: 12px; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.7); border: 1px solid #333; aspect-ratio: 16 / 9; }
        canvas#outputCanvas { width: 100%; height: 100%; display: block; object-fit: contain; }

        .preview-grid { display: flex; flex-direction: column; gap: 10px; width: 220px; }
        .preview-box { background: var(--panel); border-radius: 8px; overflow: hidden; border: 1px solid #444; aspect-ratio: 16 / 9; }
        .preview-box label { font-size: 9px; padding: 4px 8px; display: block; background: #2a2a32; color: var(--accent); }
        .preview-box canvas { width: 100%; display: block; }

        .controls { background: var(--panel); padding: 20px; border-radius: 12px; width: 280px; display: flex; flex-direction: column; gap: 15px; border: 1px solid #333; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .checkbox-group { flex-direction: row; align-items: center; gap: 10px; background: rgba(0,212,255,0.1); padding: 10px; border-radius: 6px; border: 1px solid var(--accent); }
        
        label { font-size: 0.7rem; font-weight: 600; color: #aaa; text-transform: uppercase; }
        input[type="range"] { cursor: pointer; accent-color: var(--accent); }
        button { cursor: pointer; padding: 10px; border: none; border-radius: 6px; font-weight: bold; background: #333; color: white; }
        .btn-main { background: var(--accent); color: #000; }
        
        #v-hidden { display: none; }
    </style>
</head>
<body>

    <h1 style="margin-bottom:10px;">Vision Processor <span style="color:var(--accent)">v3.1</span></h1>

    <div class="main-layout">
        <div class="preview-grid">
            <div class="preview-box"><label>QUANTIZED</label><canvas id="qCanvas"></canvas></div>
            <div class="preview-box"><label>COSINE</label><canvas id="cCanvas"></canvas></div>
            <div class="preview-box"><label>SOBEL</label><canvas id="sCanvas"></canvas></div>
        </div>

        <div class="viewport-section">
            <div class="canvas-container"><canvas id="outputCanvas"></canvas></div>
        </div>

        <div class="controls">
            <button class="btn-main" id="init-btn">Initialize Camera</button>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="combine-mode" checked>
                <label for="combine-mode" style="color: #fff; cursor: pointer;">2x2 Grid Mode</label>
            </div>
            <div class="control-group">
                <label>Quantization (Steps): <span id="q-val">8</span></label>
                <input type="range" id="quantize" min="2" max="32" value="8">
            </div>
            <div class="control-group">
                <label>Wave Intensity: <span id="c-val">0</span></label>
                <input type="range" id="cosine" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Edge Strength: <span id="s-val">0</span></label>
                <input type="range" id="sobel" min="0" max="2" step="0.1" value="0">
            </div>
            <button id="snap" style="background:#4CAF50">Save Output</button>
        </div>
    </div>

    <video id="v-hidden" autoplay playsinline></video>

<script>
    const video = document.getElementById('v-hidden');
    const mainCanvas = document.getElementById('outputCanvas');
    const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
    
    const previews = {
        q: { canvas: document.getElementById('qCanvas'), ctx: document.getElementById('qCanvas').getContext('2d', {willReadFrequently: true}) },
        c: { canvas: document.getElementById('cCanvas'), ctx: document.getElementById('cCanvas').getContext('2d', {willReadFrequently: true}) },
        s: { canvas: document.getElementById('sCanvas'), ctx: document.getElementById('sCanvas').getContext('2d', {willReadFrequently: true}) }
    };
    
    const combineCheck = document.getElementById('combine-mode');
    const qSlider = document.getElementById('quantize');
    const cSlider = document.getElementById('cosine');
    const sSlider = document.getElementById('sobel');

    const W = 640; // Internal processing width (16:9)
    const H = 360; // Internal processing height

    document.getElementById('init-btn').addEventListener('click', async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { aspectRatio: 1.777 } });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                mainCanvas.width = W;
                mainCanvas.height = H;
                Object.values(previews).forEach(p => { p.canvas.width = W; p.canvas.height = H; });
                document.getElementById('init-btn').style.display = 'none';
                processFrame();
            };
        } catch (err) { alert("Camera Error: " + err.message); }
    });

    function processFrame() {
        const qVal = parseInt(qSlider.value);
        const cVal = parseInt(cSlider.value);
        const sVal = parseFloat(sSlider.value);

        document.getElementById('q-val').innerText = qVal;
        document.getElementById('c-val').innerText = cVal;
        document.getElementById('s-val').innerText = sVal;

        // 1. Core Filter Logic
        renderQuantize(qVal);
        renderCosine(cVal);
        renderSobel(sVal);

        // 2. Final Compositing
        mainCtx.fillStyle = "#000";
        mainCtx.fillRect(0, 0, W, H);

        if (combineCheck.checked) {
            const hw = W / 2;
            const hh = H / 2;
            // Grid 2x2
            mainCtx.drawImage(video, 0, 0, hw, hh);              // Top Left: Raw
            mainCtx.drawImage(previews.q.canvas, hw, 0, hw, hh); // Top Right: Quant
            mainCtx.drawImage(previews.c.canvas, 0, hh, hw, hh); // Bottom Left: Cosine
            mainCtx.drawImage(previews.s.canvas, hw, hh, hw, hh);// Bottom Right: Sobel
        } else {
            mainCtx.drawImage(video, 0, 0, W, H);
        }

        requestAnimationFrame(processFrame);
    }

    function renderQuantize(levels) {
        const {ctx, canvas} = previews.q;
        ctx.drawImage(video, 0, 0, W, H);
        let frame = ctx.getImageData(0, 0, W, H);
        let data = frame.data;
        
        // True depth reduction logic
        const step = 255 / (levels - 1);
        for (let i = 0; i < data.length; i += 4) {
            data[i]   = Math.round(data[i] / step) * step;     // Red
            data[i+1] = Math.round(data[i+1] / step) * step;   // Green
            data[i+2] = Math.round(data[i+2] / step) * step;   // Blue
        }
        ctx.putImageData(frame, 0, 0);
    }

    function renderCosine(intensity) {
        const {ctx, canvas} = previews.c;
        ctx.drawImage(video, 0, 0, W, H);
        if (intensity === 0) return;
        let frame = ctx.getImageData(0, 0, W, H);
        let data = frame.data;
        for (let i = 0; i < data.length; i += 4) {
            const x = (i / 4) % W;
            const wave = Math.cos(x * 0.1) * intensity;
            data[i] += wave; data[i+1] += wave; data[i+2] += wave;
        }
        ctx.putImageData(frame, 0, 0);
    }

    function renderSobel(strength) {
        const {ctx, canvas} = previews.s;
        ctx.drawImage(video, 0, 0, W, H);
        if (strength === 0) return;
        const src = ctx.getImageData(0, 0, W, H).data;
        const target = ctx.createImageData(W, H);
        const dst = target.data;
        for (let y = 1; y < H - 1; y++) {
            for (let x = 1; x < W - 1; x++) {
                const i = (y * W + x) * 4;
                const hX = -src[i-4-W*4] + src[i+4-W*4] - 2*src[i-4] + 2*src[i+4] - src[i-4+W*4] + src[i+4+W*4];
                const hY = -src[i-4-W*4] - 2*src[i-W*4] - src[i+4-W*4] + src[i-4+W*4] + 2*src[i+W*4] + src[i+4+W*4];
                const edge = Math.sqrt(hX*hX + hY*hY) * strength;
                dst[i] = edge; dst[i+1] = edge; dst[i+2] = edge; dst[i+3] = 255;
            }
        }
        ctx.putImageData(target, 0, 0);
    }

    document.getElementById('snap').onclick = () => {
        const link = document.createElement('a');
        link.download = `vision-${Date.now()}.png`;
        link.href = mainCanvas.toDataURL();
        link.click();
    };
</script>
</body>
</html>
