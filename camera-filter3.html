<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Grid - Real-Time Pro</title>
    <style>
        :root { --accent: #00d4ff; --bg: #0b0b0e; --panel: #16161a; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .main-layout { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 1400px; }
        .viewport-section { flex: 2; min-width: 300px; }
        .canvas-container { width: 100%; background: #000; border-radius: 12px; overflow: hidden; border: 1px solid #333; }
        canvas { width: 100%; height: auto; display: block; }
        .controls { flex: 1; background: var(--panel); padding: 25px; border-radius: 12px; min-width: 280px; display: flex; flex-direction: column; gap: 15px; }
        label { font-size: 0.7rem; font-weight: 700; color: #777; text-transform: uppercase; }
        input[type="range"] { accent-color: var(--accent); }
        button { cursor: pointer; padding: 12px; border: none; border-radius: 6px; font-weight: bold; background: var(--accent); color: #000; width: 100%; }
        #v-hidden { display: none; }
        .val-display { color: var(--accent); float: right; }
    </style>
</head>
<body>

    <h1 style="letter-spacing:-1px">Vision <span style="color:var(--accent)">Grid</span></h1>

    <div class="main-layout">
        <div class="viewport-section">
            <div class="canvas-container"><canvas id="outputCanvas"></canvas></div>
        </div>

        <div class="controls">
            <button id="init-btn">Start Real-Time Engine</button>
            <div class="control-group" style="flex-direction:row; align-items:center; gap:10px;">
                <input type="checkbox" id="combine-mode" checked>
                <label for="combine-mode" style="color:#eee; cursor:pointer;">2x2 Grid View</label>
            </div>
            <div class="control-group">
                <label>Quantization <span class="val-display" id="q-val">1</span></label>
                <input type="range" id="quantize" min="1" max="255" value="1">
            </div>
            <div class="control-group">
                <label>Cosine Wave <span class="val-display" id="c-val">0</span></label>
                <input type="range" id="cosine" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Edge Detection <span class="val-display" id="s-val">0</span></label>
                <input type="range" id="sobel" min="0" max="2" step="0.1" value="0">
            </div>
        </div>
    </div>

    <video id="v-hidden" autoplay playsinline></video>

<script>
    const video = document.getElementById('v-hidden');
    const mainCanvas = document.getElementById('outputCanvas');
    const mainCtx = mainCanvas.getContext('2d', { alpha: false });
    
    // Performance optimized buffers
    const buffers = { q: document.createElement('canvas'), c: document.createElement('canvas'), s: document.createElement('canvas') };
    const bCtx = { 
        q: buffers.q.getContext('2d', { willReadFrequently: true }), 
        c: buffers.c.getContext('2d', { willReadFrequently: true }), 
        s: buffers.s.getContext('2d', { willReadFrequently: true }) 
    };

    let streamW, streamH, procW, procH;

    document.getElementById('init-btn').addEventListener('click', async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            streamW = video.videoWidth;
            streamH = video.videoHeight;
            // Processing resolution (Balanced for speed/detail)
            procW = 640; 
            procH = (streamH / streamW) * 640;

            mainCanvas.width = streamW;
            mainCanvas.height = streamH;
            Object.values(buffers).forEach(b => { b.width = procW; b.height = procH; });
            document.getElementById('init-btn').style.display = 'none';
            requestAnimationFrame(processFrame);
        };
    });

    function processFrame() {
        const qDiv = parseInt(document.getElementById('quantize').value);
        const cVal = parseInt(document.getElementById('cosine').value);
        const sVal = parseFloat(document.getElementById('sobel').value);

        document.getElementById('q-val').innerText = qDiv;
        document.getElementById('c-val').innerText = cVal;
        document.getElementById('s-val').innerText = sVal;

        // 1. Mirrored Drawing Logic
        const hw = streamW / 2;
        const hh = streamH / 2;
        const phw = procW / 2;
        const phh = procH / 2;

        if (document.getElementById('combine-mode').checked) {
            // TOP LEFT: RAW (Direct Mirror)
            mainCtx.setTransform(-1, 0, 0, 1, hw, 0);
            mainCtx.drawImage(video, 0, 0, hw, hh);

            // Filter Processing (only if slider is moved to save CPU)
            applyQuantize(qDiv);
            applyCosine(cVal);
            applySobel(sVal);

            // DRAW BUFFERS TO MAIN
            mainCtx.setTransform(1, 0, 0, 1, 0, 0);
            mainCtx.drawImage(buffers.q, hw, 0, hw, hh);
            mainCtx.drawImage(buffers.c, 0, hh, hw, hh);
            mainCtx.drawImage(buffers.s, hw, hh, hw, hh);
            
            // GRID LINES
            mainCtx.strokeStyle = "rgba(0,212,255,0.3)";
            mainCtx.strokeRect(0, 0, streamW, streamH);
        } else {
            mainCtx.setTransform(-1, 0, 0, 1, streamW, 0);
            mainCtx.drawImage(video, 0, 0, streamW, streamH);
        }

        requestAnimationFrame(processFrame);
    }

    function applyQuantize(divisor) {
        bCtx.q.setTransform(-1, 0, 0, 1, procW, 0);
        bCtx.q.drawImage(video, 0, 0, procW, procH);
        if (divisor <= 1) return;
        const imgData = bCtx.q.getImageData(0, 0, procW, procH);
        const d = imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            d[i] = (d[i] / divisor | 0) * divisor;
            d[i+1] = (d[i+1] / divisor | 0) * divisor;
            d[i+2] = (d[i+2] / divisor | 0) * divisor;
        }
        bCtx.q.putImageData(imgData, 0, 0);
    }

    function applyCosine(intensity) {
        bCtx.c.setTransform(-1, 0, 0, 1, procW, 0);
        bCtx.c.drawImage(video, 0, 0, procW, procH);
        if (intensity === 0) return;
        const imgData = bCtx.c.getImageData(0, 0, procW, procH);
        const d = imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const wave = Math.cos(((i/4)%procW) * 0.1) * intensity;
            d[i] += wave; d[i+1] += wave; d[i+2] += wave;
        }
        bCtx.c.putImageData(imgData, 0, 0);
    }

    function applySobel(strength) {
        bCtx.s.setTransform(-1, 0, 0, 1, procW, 0);
        bCtx.s.drawImage(video, 0, 0, procW, procH);
        if (strength === 0) return;
        const src = bCtx.s.getImageData(0, 0, procW, procH).data;
        const target = bCtx.s.createImageData(procW, procH);
        const dst = target.data;
        const w = procW;
        // Optimized 3x3 Sobel kernel
        for (let i = w * 4; i < src.length - w * 4; i += 4) {
            const hX = -src[i-4-w*4] + src[i+4-w*4] - 2*src[i-4] + 2*src[i+4] - src[i-4+w*4] + src[i+4+w*4];
            const hY = -src[i-4-w*4] - 2*src[i-w*4] - src[i+4-w*4] + src[i-4+w*4] + 2*src[i+w*4] + src[i+4+w*4];
            const edge = Math.sqrt(hX*hX + hY*hY) * strength;
            dst[i] = dst[i+1] = dst[i+2] = edge; dst[i+3] = 255;
        }
        bCtx.s.putImageData(target, 0, 0);
    }
</script>
</body>
</html>
